/**
 * Copyright (c) 2015 Anup Patel.
 *               2016 Open Wide
 *               2016 Institut de Recherche Technologique SystemX
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * @file zero.c
 * @author Anup Patel (anup@brainfault.org)
 * @brief Simple pass-through emulator.
 *
 * This emulator to should be use for pass-through access to non-DMA
 * capable device which do not require IOMMU, CLK, and PINMUX configuration.
 */

#include <vmm_error.h>
#include <vmm_heap.h>
#include <vmm_stdio.h>
#include <vmm_host_irq.h>
#include <vmm_modules.h>
#include <vmm_host_aspace.h>
#include <vmm_devtree.h>
#include <vmm_devemu.h>

#define MODULE_DESC			"Simple Pass-through Emulator"
#define MODULE_AUTHOR			"Anup Patel"
#define MODULE_LICENSE			"GPL"
#define MODULE_IPRIORITY		0
#define	MODULE_INIT			simple_emulator_init
#define	MODULE_EXIT			simple_emulator_exit

#define MEMORY_PASSTHROUGH_ATTR "memory-passthrough"
#define VERBOSITY_ATTR          "verbosity"

enum verbosity {
        VERBOSITY_NONE       = 0,
        VERBOSITY_READ       = (1 << 0),
        VERBOSITY_WRITE      = (1 << 1),
        VERBOSITY_READ_WRITE = (VERBOSITY_READ | VERBOSITY_WRITE),

        __VERBOSITY_LAST /* Sentinel */
};

enum memory_pt {
        MEMORY_PT_NONE       = 0,
        MEMORY_PT_READ       = (1 << 0),
        MEMORY_PT_WRITE      = (1 << 1),
        MEMORY_PT_READ_WRITE = (MEMORY_PT_READ | MEMORY_PT_WRITE),

        __MEMORY_PT_LAST /* Sentinel */
};

struct simple_state {
	char name[64];
	struct vmm_guest *guest;
	u32 irq_count;
	u32 *host_irqs;
	u32 *guest_irqs;
        u32 memory_pt;
        u32 verbosity;
};


/*============================================================================*
 *                         Pass-Through Memory Access                         *
 *============================================================================*/

static int simple_emulator_read(struct vmm_emudev *edev,
                                physical_addr_t offset,
                                u32 *dst,
                                u32 size)
{
        const struct simple_state *s = edev->priv;
        int ret;

        /* Ignore if memoty pt READ not enabled */
        if (!(s->memory_pt & MEMORY_PT_READ)) {
                return VMM_OK;
        }

        ret = vmm_host_memory_read(edev->reg->hphys_addr + offset,
                                   dst, size, false);

        if (s->verbosity & VERBOSITY_READ) {
                vmm_printf("[PT/%s]: [0x%"PRIPADDR"] => 0x%"PRIx32". "
                           "Read %"PRIu32" bytes (status: %i)\n",
                           edev->node->name, edev->reg->hphys_addr + offset,
                           *dst, size, ret);
        }

        return (ret == size) ? VMM_OK : VMM_EFAIL;
}

static int simple_emulator_write(struct vmm_emudev *edev,
                                 physical_addr_t offset,
                                 u32 val,
                                 u32 mask,
                                 u32 size)
{
        const struct simple_state *s = edev->priv;
        int ret;

        /* Ignore if memoty pt WRITE not enabled */
        if (!(s->memory_pt & MEMORY_PT_WRITE)) {
                return VMM_OK;
        }

        ret = vmm_host_memory_write(edev->reg->hphys_addr + offset,
                                    &val, size, false);

        if (s->verbosity & VERBOSITY_WRITE) {
                vmm_printf("[PT/%s]: [0x%"PRIPADDR"] <= 0x%"PRIx32". "
                           "Wrote %"PRIu32" bytes (status: %i)\n",
                           edev->node->name, edev->reg->hphys_addr + offset,
                           val, size, ret);
        }

        return (ret == size) ? VMM_OK : VMM_EFAIL;
}

/* Handle host-to-guest routed IRQ generated by device */
static vmm_irq_return_t simple_routed_irq(int irq, void *dev)
{
	int rc;
	bool found = FALSE;
	u32 i, host_irq = irq, guest_irq = 0;
	struct simple_state *s = dev;

        vmm_printf("\n=================\n"
                     "================= => IRQ %i\n\n", irq);

	/* Find guest irq */
	for (i = 0; i < s->irq_count; i++) {
		if (s->host_irqs[i] == host_irq) {
			guest_irq = s->guest_irqs[i];
			found = TRUE;
			break;
		}
	}
	if (!found) {
		goto done;
	}

	/* Lower the interrupt level.
	 * This will clear previous interrupt state.
	 */
	rc = vmm_devemu_emulate_irq(s->guest, guest_irq, 0);
	if (rc) {
		vmm_printf("%s: Emulate Guest=%s irq=%d level=0 failed\n",
			   __func__, s->guest->name, guest_irq);
	}

	/* Elevate the interrupt level.
	 * This will force interrupt triggering.
	 */
	rc = vmm_devemu_emulate_irq(s->guest, guest_irq, 1);
	if (rc) {
		vmm_printf("%s: Emulate Guest=%s irq=%d level=1 failed\n",
			   __func__, s->guest->name, guest_irq);
	}

done:
	return VMM_IRQ_HANDLED;
}

static int simple_emulator_reset(struct vmm_emudev *edev)
{
	u32 i;
	struct simple_state *s = edev->priv;

	for (i = 0; i < s->irq_count; i++) {
		vmm_devemu_map_host2guest_irq(s->guest,
					      s->guest_irqs[i],
					      s->host_irqs[i]);
	}

	return VMM_OK;
}

static int simple_emulator_probe(struct vmm_guest *guest,
				 struct vmm_emudev *edev,
				 const struct vmm_devtree_nodeid *eid)
{
	int rc = VMM_OK;
	u32 i, irq_reg_count = 0;
	struct simple_state *s;

	s = vmm_zalloc(sizeof(struct simple_state));
	if (!s) {
		rc = VMM_ENOMEM;
		goto simple_emulator_probe_fail;
	}

	strlcpy(s->name, guest->name, sizeof(s->name));
	strlcat(s->name, "/", sizeof(s->name));
	if (strlcat(s->name, edev->node->name, sizeof(s->name)) >=
							sizeof(s->name)) {
		rc = VMM_EOVERFLOW;
		goto simple_emulator_probe_freestate_fail;
	}

	s->guest = guest;
	s->irq_count = vmm_devtree_irq_count(edev->node);
	s->guest_irqs = NULL;
	s->host_irqs = NULL;
        s->memory_pt = MEMORY_PT_NONE;
        s->verbosity = VERBOSITY_NONE;

        /* Is it a memory pass-though? */
        i = vmm_devtree_attrlen(edev->node, MEMORY_PASSTHROUGH_ATTR) / sizeof(u32);
        if (i > 0) {
                rc = vmm_devtree_read_u32_atindex(edev->node,
                                                  MEMORY_PASSTHROUGH_ATTR,
                                                  &s->memory_pt, 0);
                if (s->memory_pt >= __MEMORY_PT_LAST) {
                        rc = VMM_EINVALID;
                        vmm_printf("*** Invalid "MEMORY_PASSTHROUGH_ATTR" value: "
                                   "0x%"PRIx32"\n", s->memory_pt);
                        goto simple_emulator_probe_freestate_fail;
                }
        }

        /* Get verbosity */
        i = vmm_devtree_attrlen(edev->node, VERBOSITY_ATTR) / sizeof(u32);
        if (i > 0) {
                rc = vmm_devtree_read_u32_atindex(edev->node,
                                                  VERBOSITY_ATTR,
                                                  &s->verbosity, 0);
                if (s->verbosity >= __VERBOSITY_LAST) {
                        rc = VMM_EINVALID;
                        vmm_printf("*** Invalid "VERBOSITY_ATTR" value: "
                                   "0x%"PRIx32"\n", s->verbosity);
                        goto simple_emulator_probe_freestate_fail;
                }
        }


	i = vmm_devtree_attrlen(edev->node, "host-interrupts") / sizeof(u32);
	if (s->irq_count != i) {
		rc = VMM_EINVALID;
		goto simple_emulator_probe_freestate_fail;
	}

	if (s->irq_count) {
		s->host_irqs = vmm_zalloc(sizeof(u32) * s->irq_count);
		if (!s->host_irqs) {
			rc = VMM_ENOMEM;
			goto simple_emulator_probe_freestate_fail;
		}

		s->guest_irqs = vmm_zalloc(sizeof(u32) * s->irq_count);
		if (!s->guest_irqs) {
			rc = VMM_ENOMEM;
			goto simple_emulator_probe_freehirqs_fail;
		}
	}

	for (i = 0; i < s->irq_count; i++) {
		rc = vmm_devtree_read_u32_atindex(edev->node,
						  "host-interrupts",
						  &s->host_irqs[i], i);
		if (rc) {
			goto simple_emulator_probe_cleanupirqs_fail;
		}

                char *nn = vmm_malloc(10);
                vmm_snprintf(nn, 10, "%i", s->host_irqs[i]);
                nn[3] = 0;
                nn[9] = 0;

                rc = vmm_host_irq_register(s->host_irqs[i], nn, simple_routed_irq, NULL);
                if (rc != VMM_OK){
                        vmm_printf("**** Fail for irq %"PRIu32"!\n", s->host_irqs[i]);
                        continue;
                }

		rc = vmm_devtree_irq_get(edev->node, &s->guest_irqs[i], i);
		if (rc) {
			goto simple_emulator_probe_cleanupirqs_fail;
		}

                vmm_printf("%s: binding guest IRQ %"PRIu32" to host IRQ %"PRIu32"\n",
                           s->name, s->guest_irqs[i], s->host_irqs[i]);


		rc = vmm_host_irq_mark_routed(s->host_irqs[i]);
		if (rc) {
			goto simple_emulator_probe_cleanupirqs_fail;
		}

		rc = vmm_host_irq_register(s->host_irqs[i], s->name,
					   simple_routed_irq, s);
		if (rc) {
			vmm_host_irq_unmark_routed(s->host_irqs[i]);
			goto simple_emulator_probe_cleanupirqs_fail;
		}

                vmm_host_irq_enable( s->host_irqs[i]);
                vmm_host_irq_unmask( s->host_irqs[i]);
		irq_reg_count++;
	}

        vmm_printf("%s: simple/pt. Memory flags: 0x%"PRIx32". Verbosity: 0x%"PRIx32"\n",
                   s->name, s->memory_pt, s->verbosity);
	edev->priv = s;

	return VMM_OK;

simple_emulator_probe_cleanupirqs_fail:
	for (i = 0; i < irq_reg_count; i++) {
		vmm_host_irq_unregister(s->host_irqs[i], s);
		vmm_host_irq_unmark_routed(s->host_irqs[i]);
	}
	if (s->guest_irqs) {
		vmm_free(s->guest_irqs);
	}
simple_emulator_probe_freehirqs_fail:
	if (s->host_irqs) {
		vmm_free(s->host_irqs);
	}
simple_emulator_probe_freestate_fail:
	vmm_free(s);
simple_emulator_probe_fail:
	return rc;
}

static int simple_emulator_remove(struct vmm_emudev *edev)
{
	u32 i;
	struct simple_state *s = edev->priv;

	if (!s) {
		return VMM_EFAIL;
	}

	for (i = 0; i < s->irq_count; i++) {
		vmm_host_irq_unregister(s->host_irqs[i], s);
		vmm_host_irq_unmark_routed(s->host_irqs[i]);
	}
	if (s->guest_irqs) {
		vmm_free(s->guest_irqs);
	}
	if (s->host_irqs) {
		vmm_free(s->host_irqs);
	}
	vmm_free(s);

        vmm_printf("======= REMOVING %p %p\n", edev, edev->priv);
	edev->priv = NULL;

	return VMM_OK;
}

static struct vmm_devtree_nodeid simple_emuid_table[] = {
	{ .type = "pt", .compatible = "simple", },
	{ /* end of list */ },
};

VMM_DECLARE_EMULATOR_SIMPLE(simple_emulator,
                            "simple",
                            simple_emuid_table,
                            VMM_DEVEMU_NATIVE_ENDIAN,
                            simple_emulator_probe,
                            simple_emulator_remove,
                            simple_emulator_reset,
                            simple_emulator_read,
                            simple_emulator_write);

static int __init simple_emulator_init(void)
{
	return vmm_devemu_register_emulator(&simple_emulator);
}

static void __exit simple_emulator_exit(void)
{
	vmm_devemu_unregister_emulator(&simple_emulator);
}

VMM_DECLARE_MODULE(MODULE_DESC,
			MODULE_AUTHOR,
			MODULE_LICENSE,
			MODULE_IPRIORITY,
			MODULE_INIT,
			MODULE_EXIT);
